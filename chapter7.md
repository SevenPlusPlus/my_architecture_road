---
## 我们的分布式事务解决之道

### 背景介绍

随着公司后台从单体API-web服务到分布式服务化的架构调整，业务从原先耦合的整体逐步拆解为一个个独立的业务模块，同时为了保持业务模块独立、稳定和对外封闭性（仅支持外部通过接口访问），原则上要求业务模块使用自己独立的存储和缓存，这必然导致原先一个业务功能需要跨多个业务模块调用而引入分布式事务问题。结合对于目前公司的业务，分布式事务主要会体现在消费类场景中（充值、送礼、购买座驾、购买VIP等），而且对用户体验影响也很大。如购买座驾会有扣币、增加秀币流水、增加座驾、增加购买流水等关键步骤，涉及API、用户中心、商城等多个业务模块或组件，这些关键步骤构成一个完整的事务，任何一个失败都会导致整体业务数据的不一致。

### 分布式方案选型

分布式事务问题解决方案世面上有很多，针对数据一致性的要求级别，方案复杂度也各异，如两阶段提交、TCC、消息异步消费模型等等，这些方案或者会引入过高的复杂度，或者与我们目前架构实践相去甚远、改造遥遥无期。因此我们设计了这样一个相对妥协的分布式事务方案（消费对账中心），即在不对目前系统伤筋动骨的基础上，及时定位分布式事务不一致数据、事后补齐的方案。

### 事务消费对账方案设计

方案的核心思想就是通过整合分布式事务中的各个参与业务模块的事务记录来达到快速定位异常事务的目的，并根据事务具体场景结合事务处理中失败的具体步骤来人工（或自动）或重试失败操作、或补偿回滚来达到数据的最终一致性。
方案整体架构包括三个部分：1）事务消息埋点框架工具包，提供事务及关键步骤事件埋点记录接口，保证事务消息唯一并确保送达；2）事务消息消费组件，实时幂等的消费事务消息，并将事务、事件记录入库，提供相应的查询统计接口；3）对账处理后台，提供后台可以查询异常事务，设置处理对账结果。详细架构如下图所示：

![](/assets/事务消费对账方案.png)

### 事务消息框架设计

一个事务消息有一个唯一的事务ID，事务消息中可以包含若干顺序步骤事件消息，事务或事件消息可以设置自定义属性、参数列表等信息，事务或事件结束时设置处理结果状态，本地方法处理过程结束时发送事务消息至MQ。事务开始时新建一个Transaction消息自动生成一个全局唯一的TransactionId(事务号), 事务处理过程每个关键步骤开始时新建一个Event消息，EventID（事件序号）按顺序递增，发起跨业务模块的RPC调用时自动传递当前的TransactionId和该处调用对应的EventID作为该远程调用的上下文发送至下级业务模块服务中。消息模型见下图所示：

![](/assets/事务消息树实例.png)

例如用户购买座驾的消费行为，调用api的购买汽车接口，api调用商城模块进行买车操作，商城模块中调用了用户中心进行扣币和增加座驾的操作，而商城模块自身会操作数据添加流水等操作。那么其简单流程如下：

1. API: 新建transaction生成全局唯一的TansactionId=10000，调用商场模块购买座驾接口方法，新增步骤事件carService.buyCar，此时事件ID为1
2. 商城模块：购买座驾接口方法，根据从RPC调用上下文中获取到本次transaction的TansactionId=10000,EventId=1.1，新建子transaction。调用用户中心扣秀币接口方法，新增步骤事件userService.decreaseMoney，此时调用步骤事件ID为1.1。
3. 用户中心：加减秀币接口方法，根据从RPC调用上下文中获取到本次transaction的TansactionId=10000,EventId=1.1.1，新建子transaction。操作数据库扣秀币，新增步骤事件sql.incUserAssets，此时调用步骤事件ID为1.1.1。用户中心扣秀币事务结束，设置处理状态，发送MQ事务消息transaction(transactionId=10000,pEvent=1.1,eventList=[1.1.1,1.1.2])。
4. 商城模块：步骤2）成功，调用用户中心增加用户资源接口方法，新增步骤事件userService.addResource此时调用埋点事件ID为1.2。
5. 用户中心：增加用户资源接口方法，根据从RPC调用上下文中获取到本次transaction的TansactionId=10000,EventId=1.2.1，新建子transaction。操作数据库增加用户座驾，新增步骤事件sql.addUserResource，此时调用步骤事件ID为1.2.1。用户中心增加用户资源事务结束，设置处理状态，发送MQ事务消息transaction(transactionId=10000,pEvent=1.2,eventList=[1.2.1])。
6. 商城模块：步骤4）成功，操作数据库新增购买座驾流水，新增步骤事件sql.buycar此时调用埋点事件ID为1.3。商城模块事务结束，设置处理状态，发送MQ事务消息
transaction(transactionId=10000,pEvent=1,eventList=[1.1,1.2,1.3])。
7. API：API购买座驾事务结束，设置处理状态，发送MQ事务消息
transaction(transactionId=10000,pEvent=null,eventList=[1])。

可以看出，一个涉及三次远程调用的分布式事务，在事务消息模型中，一次成功的购买会产生4条transaction消息。他们拥有相同的TransactionId和过程中详细的操作步骤及操作状态，从而形成了一棵完整的过程调用树，整个事务过程中任何一个步骤出现问题都很容易定位，再加上每一步失败原因和失败调用时参数的埋点，很容易就可以得出补帐的策略和动作，从而保证数据的最终一致性。

### 接口设计

用户可以使用注解实现事务消息埋点，注解分为@ClassTransactional和@LogTransactional,@ClassTransactional用作表示类下的所有方法开启事务埋点，@LogTransactional则针对具体方法开启事务埋点。

### 事务对账中心

![](/assets/事务对账中心.png)

## XA二阶段提交回顾

### XA协议

XA是一个分布式事务协议，由Tuxedo提出。XA中大致分为两部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。XA实现分布式事务的原理如下：

![](/assets/XA协议.png)

仅在同一个事务上下文中需要协调多种资源（即数据库，以及消息主题或队列）时，才有必要使用X/Open XA接口。	XA最常见的场景是在同一个事务中协调数据库更改和消息队列（或主题）。注意这两种操作有可能在应用完全不同的地方出现（特别是在使用像hibernate这样的ORM框架的时候）。XA事务必须在回滚事件发生时协调两种类型的资源，或让更改与其他事务保持隔离。如果没有XA，送往队列或主题的消息甚至会在事务终止前到达并被读取。而在XA环境下，队列中的消息在事务提交之前不会被释放。

### 两阶段提交协议2PC

两阶段提交协议（The two-phase commit protocol，2PC）是XA用于在全局事务中协调多个资源的机制。两阶段协议遵循OSI（Open System Interconnection，开放系统互联）/DTP标准，虽然它比标准本身早若干年出现。
两阶段提交协议包含了两个阶段： 
* 	第一阶段：称为准备(prepare)阶段。事务协调者向各个服务应用发送prepare请求，服务应用在得到请求后做预处理操作，预处理可能是做预检查，也可能是把请求临时存储，可以理解为是一种试探性地提交。下面是一般的步骤：
	
1. 事务协调者会问所有的参与者服务，是否可以提交操作。
2. 各个参与者开始事务执行的准备工作：如资源上锁，预留资源，写回滚/重试的log。
3. 参与者响应协调者，如果事务准备工作成功，则回应“可以提交”，否则回应拒绝提交。
	
* 第二阶段：称为提交(commit)/回滚(rollback)阶段。是指事务真正提交或者回滚的阶段。如果事务协调者发现事务参与者有一个在prepare阶段出现失败，则会要求所有的参与者进行回滚。如果协调者发现所有的参与者都prepare操作都是成功，那么他将向所有的参与者发出提交请求，这时所有参与者才会正式提交。由此保证了要求全部提交成功，要么全部失败。
 
下面是具体步骤：
1. 如果所有的参与者都回应“可以提交”，那么协调者向所有参与者发送“正式提交”的命令。参与者完成正式提交，并释放所有资源，然后回应“完成”，协调者收集各个服务的“完成”回应后结束事务。
2. 如果有一个参与者回应“拒绝提交”，那么协调者向所有的参与者发送“回滚操作”，并释放所有的资源，然后回应“回滚完成”，协调者收集各个服务应用的“回滚”返回后，取消整体的分布式事务。
	
两阶段提交看起来确实能够提供原子性的操作，但是不幸的事，两阶段提交还是有几个缺点的：
* 同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
* 单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）
* 数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。

二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。
由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。

### 三阶段提交协议3PC

三阶段提交（Three-phase commit），也叫三阶段提交协议（Three-phase commit protocol），是两阶段提交（2PC）的改进版本。

![](/assets/三阶段提交.png)

与两阶段提交不同的是，三阶段提交有两个改动点。
1. 引入超时机制。同时在协调者和参与者中都引入超时机制。
2. 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。
也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。

* CanCommit阶段

3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。
1. 事务询问 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。
2. 响应反馈 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No

* PreCommit阶段

协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。根据响应情况，有以下两种可能。
假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。
1. 发送预提交请求 协调者向参与者发送PreCommit请求，并进入Prepared阶段。
2. 事务预提交 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。
3. 响应反馈 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。

假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。
1. 发送中断请求 协调者向所有参与者发送abort请求。
2. 中断事务 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。

* doCommit阶段
该阶段进行真正的事务提交，也可以分为以下两种情况。
  * 执行提交
1. 发送提交请求 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。
2. 事务提交 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。
3. 响应反馈 事务提交完之后，向协调者发送Ack响应。
4. 完成事务 协调者接收到所有参与者的ack响应之后，完成事务。
  * 中断事务 协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。
1. 发送中断请求 协调者向所有参与者发送abort请求
2. 事务回滚 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。
3. 反馈结果 参与者完成事务回滚之后，向协调者发送ACK消息
4. 中断事务 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。

## TCC分布式事务框架

### TCC简介

TCC是分布式事务实现的一种方式

TRY：尝试执行业务
* 	完成所有业务检查（一致性）
* 	预留必须业务资源（准隔离性）

CONFIRM：确认执行业务
*   真正执行业务
*	不做任何业务检查
*	只使用TRY阶段预留的业务资源
*	CONFIRM操作满足幂等性

CONCEL：取消执行业务
*	释放TRY阶段预留的业务资源
*   CONCEL操作满足幂等性

### TCC特点与适用场景

TCC也是一个有着特定应用场景的模式

TCC适用范围：

*	强隔离性、严格一致性要求的业务活动。
*	适用于执行时间较短的业务。

TCC开发局限及成本：

*	很多场景下预留业务资源成本高，可能需要引入锁、本地局部事务等。
*	很多场景下实现CONFIRM及CONCEL阶段的幂等成本高。常见的幂等实现方式有：通过唯一键值做处理，即每次调用的时候传入唯一键值，通过唯一键值判断业务是否被操作，如果已被操作，则不再重复操作；通过状态机处理，给业务数据设置状态，通过业务状态判断是否需要重复执行。

### TCC与两阶段提交的区别

两阶段提交（Two Phase Commit，下文简称2PC），简单的说，是将事务的提交操作分成了prepare、commit两个阶段。其事务处理方式为：

1. 在全局事务决定提交时，a）逐个向RM发送prepare请求；b）若所有RM都返回OK，则逐个发送commit请求最终提交事务；否则，逐个发送rollback请求来回滚事务；
2. 在全局事务决定回滚时，直接逐个发送rollback请求即可，不必分阶段。
* 需要注意的是：2PC机制需要RM提供底层支持（一般是兼容XA），而TCC机制则不需要。
	
TCC（Try-Confirm-Cancel），则是将业务逻辑分成try、confirm/cancel两个阶段执行。其事务处理方式为：
1. 在全局事务决定提交时，调用与try业务逻辑相对应的confirm业务逻辑；
2. 在全局事务决定回滚时，调用与try业务逻辑相对应的cancel业务逻辑。

可见，TCC在事务处理方式上，是很简单的：要么调用confirm业务逻辑，要么调用cancel逻辑。这里为什么没有提到try业务逻辑呢？因为try逻辑与全局事务处理无关。
	
当讨论2PC时，我们只专注于事务处理阶段，因而只讨论prepare和commit，所以，可能很多人都忘了，使用2PC事务管理机制时也是有业务逻辑阶段的。正是因为业务逻辑的执行，发起了全局事务，这才有其后的事务处理阶段。实际上，使用2PC机制时――――以提交为例――――一个完整的事务生命周期是：begin -> 业务逻辑 -> prepare -> commit。
	
再看TCC，也不外乎如此。我们要发起全局事务，同样也必须通过执行一段业务逻辑来实现。该业务逻辑一来通过执行触发TCC全局事务的创建；二来也需要执行部分数据写操作；此外，还要通过执行来向TCC全局事务注册自己，以便后续TCC全局事务commit/rollback时回调其相应的confirm/cancel业务逻辑。所以，使用TCC机制时――――以提交为例――――一个完整的事务生命周期是：begin -> 业务逻辑(try业务) -> commit(comfirm业务)。

### TCC框架订单支付流程案例分析

![](/assets/TCC订单支付案例流程.png)